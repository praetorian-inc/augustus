package exploitation

import (
	"testing"

	"github.com/praetorian-inc/augustus/pkg/probes"
)

func TestSQLInjectionEcho(t *testing.T) {
	probe, err := NewSQLInjectionEcho(nil)
	if err != nil {
		t.Fatalf("NewSQLInjectionEcho() error = %v", err)
	}

	t.Run("Name", func(t *testing.T) {
		if got := probe.Name(); got != "exploitation.SQLInjectionEcho" {
			t.Errorf("Name() = %q, want %q", got, "exploitation.SQLInjectionEcho")
		}
	})

	t.Run("Description", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		desc := pm.Description()
		if desc == "" {
			t.Error("Description() should not be empty")
		}
	})

	t.Run("Goal", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		goal := pm.Goal()
		if goal == "" {
			t.Error("Goal() should not be empty")
		}
		if goal != "Manipulate a database via SQL injection" {
			t.Errorf("Goal() = %q, unexpected value", goal)
		}
	})

	t.Run("GetPrimaryDetector", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		if got := pm.GetPrimaryDetector(); got != "exploitation.SQLiEcho" {
			t.Errorf("GetPrimaryDetector() = %q, want %q", got, "exploitation.SQLiEcho")
		}
	})

	t.Run("GetPrompts", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		prompts := pm.GetPrompts()
		if len(prompts) != len(SQLInjectionPayloads) {
			t.Errorf("GetPrompts() len = %d, want %d", len(prompts), len(SQLInjectionPayloads))
		}
		// Verify ECHO template is used
		for _, p := range prompts {
			if !containsEchoTemplate(p) {
				t.Errorf("Prompt missing ECHO template: %s", p[:min(100, len(p))])
			}
		}
	})
}

func containsEchoTemplate(s string) bool {
	return contains(s, "ECHO:")
}
