package exploitation

import (
	"testing"

	"github.com/praetorian-inc/augustus/pkg/probes"
)

func TestSQLInjectionSystem(t *testing.T) {
	probe, err := NewSQLInjectionSystem(nil)
	if err != nil {
		t.Fatalf("NewSQLInjectionSystem() error = %v", err)
	}

	t.Run("Name", func(t *testing.T) {
		if got := probe.Name(); got != "exploitation.SQLInjectionSystem" {
			t.Errorf("Name() = %q, want %q", got, "exploitation.SQLInjectionSystem")
		}
	})

	t.Run("Description", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		desc := pm.Description()
		if desc == "" {
			t.Error("Description() should not be empty")
		}
	})

	t.Run("Goal", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		goal := pm.Goal()
		if goal == "" {
			t.Error("Goal() should not be empty")
		}
		if goal != "Manipulate a database via SQL injection" {
			t.Errorf("Goal() = %q, unexpected value", goal)
		}
	})

	t.Run("GetPrimaryDetector", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		if got := pm.GetPrimaryDetector(); got != "exploitation.SQLiSuccess" {
			t.Errorf("GetPrimaryDetector() = %q, want %q", got, "exploitation.SQLiSuccess")
		}
	})

	t.Run("GetPrompts", func(t *testing.T) {
		pm, ok := probe.(probes.ProbeMetadata)
		if !ok {
			t.Fatal("probe should implement ProbeMetadata")
		}
		prompts := pm.GetPrompts()
		expectedLen := len(SQLInjectionPayloads) + len(SQLTopInstructions)
		if len(prompts) != expectedLen {
			t.Errorf("GetPrompts() len = %d, want %d", len(prompts), expectedLen)
		}
	})
}
