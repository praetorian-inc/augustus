package exploitation

import (
	"testing"

	"github.com/praetorian-inc/augustus/pkg/probes"
)

func TestJinjaTemplatePythonInjection(t *testing.T) {
	probe, err := NewJinjaTemplatePythonInjection(nil)
	if err != nil {
		t.Fatalf("NewJinjaTemplatePythonInjection() error = %v", err)
	}

	t.Run("Name", func(t *testing.T) {
		if got := probe.Name(); got != "exploitation.JinjaTemplatePythonInjection" {
			t.Errorf("Name() = %q, want %q", got, "exploitation.JinjaTemplatePythonInjection")
		}
	})

	pm, ok := probe.(probes.ProbeMetadata)
	if !ok {
		t.Fatal("probe should implement ProbeMetadata")
	}

	t.Run("Description", func(t *testing.T) {
		desc := pm.Description()
		if desc == "" {
			t.Error("Description() should not be empty")
		}
	})

	t.Run("Goal", func(t *testing.T) {
		goal := pm.Goal()
		if goal == "" {
			t.Error("Goal() should not be empty")
		}
		if goal != "Gain remote code execution via Jinja template injection" {
			t.Errorf("Goal() = %q, unexpected value", goal)
		}
	})

	t.Run("GetPrimaryDetector", func(t *testing.T) {
		detector := pm.GetPrimaryDetector()
		if detector != "exploitation.JinjaTemplateDetector" {
			t.Errorf("GetPrimaryDetector() = %q, want %q", detector, "exploitation.JinjaTemplateDetector")
		}
	})

	t.Run("GetPrompts", func(t *testing.T) {
		prompts := pm.GetPrompts()
		if len(prompts) == 0 {
			t.Error("GetPrompts() should return prompts")
		}
		if len(prompts) != len(PythonCodeExecutionPayloads) {
			t.Errorf("GetPrompts() len = %d, want %d", len(prompts), len(PythonCodeExecutionPayloads))
		}
		// Verify Jinja syntax is present
		for _, p := range prompts {
			if !containsJinjaSyntax(p) {
				t.Errorf("Prompt missing Jinja syntax: %s", p[:min(100, len(p))])
			}
		}
	})
}

// Helper functions
func containsJinjaSyntax(s string) bool {
	return len(s) > 2 && (contains(s, "{{") && contains(s, "}}"))
}

func contains(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
